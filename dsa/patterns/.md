# Complete DSA Patterns Documentation with Problem Categories

## Table of Contents

1. [Array & String Patterns](#array--string-patterns)
2. [Linked List Patterns](#linked-list-patterns)
3. [Tree Patterns](#tree-patterns)
4. [Graph Patterns](#graph-patterns)
5. [Dynamic Programming Patterns](#dynamic-programming-patterns)
6. [Searching & Sorting Patterns](#searching--sorting-patterns)
7. [Advanced Patterns](#advanced-patterns)

---

## Array & String Patterns

### 1. Two Pointers Pattern

**Core Concept:** Use two pointers to traverse the array/string from different positions to solve problems efficiently in O(n) time.

**When to Use:**

- Finding pairs with specific sum
- Palindrome checking
- Removing duplicates
- Reversing or rearranging elements

**Implementation Template:**

```javascript
function twoPointersTemplate(arr) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    // Process current pair
    if (conditionMet) {
      // Found solution
      return result;
    } else if (needLargerSum) {
      left++;
    } else {
      right--;
    }
  }

  return defaultResult;
}
```

**Problem Categories:**

**Easy Problems:**

- Valid Palindrome
- Two Sum (sorted array)
- Remove Duplicates from Sorted Array
- Move Zeroes
- Reverse String

**Medium Problems:**

- 3Sum
- Container With Most Water
- Sort Colors
- Remove Duplicates from Sorted Array II
- Trapping Rain Water

**Hard Problems:**

- 4Sum
- Substring with Concatenation of All Words
- Minimum Window Substring

---

### 2. Sliding Window Pattern

**Core Concept:** Maintain a window of elements and slide it across the array to find optimal subarrays.

**When to Use:**

- Finding longest/shortest subarray with specific property
- Maximum sum subarray of size k
- String permutation problems
- Substring problems

**Implementation Template:**

```javascript
function slidingWindowTemplate(arr, k) {
  let windowStart = 0;
  let maxSum = -Infinity;
  let windowSum = 0;

  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {
    windowSum += arr[windowEnd]; // Add element to window

    if (windowEnd >= k - 1) {
      // Window size reached
      maxSum = Math.max(maxSum, windowSum);
      windowSum -= arr[windowStart]; // Remove from window
      windowStart++;
    }
  }

  return maxSum;
}
```

**Problem Categories:**

**Easy Problems:**

- Maximum Sum Subarray of Size K
- Average of All Subarrays of Size K
- Minimum Size Subarray Sum

**Medium Problems:**

- Longest Substring Without Repeating Characters
- Fruits into Baskets
- Longest Repeating Character Replacement
- Permutation in String
- Find All Anagrams in a String

**Hard Problems:**

- Sliding Window Maximum
- Minimum Window Substring
- Substring with Concatenation of All Words

---

### 3. Prefix Sum Pattern

**Core Concept:** Precompute cumulative sums to answer range queries in O(1) time.

**When to Use:**

- Range sum queries
- Subarray sum problems
- Finding subarrays with specific sum

**Implementation Template:**

```javascript
function prefixSumTemplate(arr) {
  const prefix = new Array(arr.length + 1).fill(0);

  for (let i = 0; i < arr.length; i++) {
    prefix[i + 1] = prefix[i] + arr[i];
  }

  // Range sum from index i to j
  function rangeSum(i, j) {
    return prefix[j + 1] - prefix[i];
  }

  return prefix;
}
```

**Problem Categories:**

**Easy Problems:**

- Range Sum Query - Immutable
- Running Sum of 1D Array
- Find Pivot Index

**Medium Problems:**

- Subarray Sum Equals K
- Continuous Subarray Sum
- Product of Array Except Self
- Range Sum Query 2D - Immutable

**Hard Problems:**

- Maximum Size Subarray Sum Equals k

---

## Linked List Patterns

### 4. Fast and Slow Pointers Pattern

**Core Concept:** Use two pointers moving at different speeds to detect cycles, find middle elements, or solve various linked list problems.

**When to Use:**

- Cycle detection in linked lists
- Finding middle of linked list
- Detecting start of cycle
- Finding nth node from end

**Implementation Template:**

```javascript
function fastSlowPointers(head) {
  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next; // Move slow pointer by 1
    fast = fast.next.next; // Move fast pointer by 2

    if (slow === fast) {
      // Cycle detected or middle found
      return slow;
    }
  }

  return null; // No cycle or reached end
}
```

**Problem Categories:**

**Easy Problems:**

- Linked List Cycle
- Middle of the Linked List
- Remove Nth Node From End of List
- Happy Number

**Medium Problems:**

- Linked List Cycle II
- Remove Duplicates from Sorted List II
- Rotate List
- Reorder List

**Hard Problems:**

- Reverse Nodes in k-Group

---

### 5. Reverse Linked List Pattern

**Core Concept:** Master reversing linked lists iteratively and recursively as building block for complex manipulations.

**When to Use:**

- Reversing entire or part of linked list
- Palindrome checking in linked lists
- Swapping nodes in pairs

**Implementation Template:**

```javascript
function reverseLinkedList(head) {
  let prev = null;
  let current = head;

  while (current) {
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }

  return prev; // New head
}

// Recursive approach
function reverseLinkedListRecursive(head) {
  if (!head || !head.next) {
    return head;
  }

  let newHead = reverseLinkedListRecursive(head.next);
  head.next.next = head;
  head.next = null;

  return newHead;
}
```

**Problem Categories:**

**Easy Problems:**

- Reverse Linked List
- Palindrome Linked List
- Merge Two Sorted Lists

**Medium Problems:**

- Reverse Linked List II
- Swap Nodes in Pairs
- Add Two Numbers
- Remove Duplicates from Sorted List II

**Hard Problems:**

- Reverse Nodes in k-Group
- Merge k Sorted Lists

---

## Tree Patterns

### 6. Tree Traversal Pattern (DFS/BFS)

**Core Concept:** Master different ways to traverse trees for various problem-solving approaches.

**When to Use:**

- Tree exploration and processing
- Finding paths or values in trees
- Tree construction and validation

**Implementation Templates:**

```javascript
// DFS - Inorder Traversal
function inorderTraversal(root) {
  const result = [];

  function dfs(node) {
    if (!node) return;

    dfs(node.left);
    result.push(node.val);
    dfs(node.right);
  }

  dfs(root);
  return result;
}

// BFS - Level Order Traversal
function levelOrder(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```

**Problem Categories:**

**Easy Problems:**

- Binary Tree Inorder Traversal
- Binary Tree Preorder Traversal
- Binary Tree Postorder Traversal
- Maximum Depth of Binary Tree
- Same Tree

**Medium Problems:**

- Binary Tree Level Order Traversal
- Binary Tree Zigzag Level Order Traversal
- Construct Binary Tree from Preorder and Inorder Traversal
- Path Sum II
- Validate Binary Search Tree

**Hard Problems:**

- Binary Tree Maximum Path Sum
- Serialize and Deserialize Binary Tree
- Recover Binary Search Tree

---

### 7. Binary Search Tree Pattern

**Core Concept:** Leverage BST properties for efficient operations and validations.

**When to Use:**

- Searching in BST
- Validating BST
- Finding kth smallest/largest elements
- Range queries in BST

**Implementation Template:**

```javascript
function validateBST(root, min = -Infinity, max = Infinity) {
  if (!root) return true;

  if (root.val <= min || root.val >= max) {
    return false;
  }

  return (
    validateBST(root.left, min, root.val) &&
    validateBST(root.right, root.val, max)
  );
}

function searchBST(root, val) {
  if (!root || root.val === val) {
    return root;
  }

  return val < root.val
    ? searchBST(root.left, val)
    : searchBST(root.right, val);
}
```

**Problem Categories:**

**Easy Problems:**

- Search in a Binary Search Tree
- Insert into a Binary Search Tree
- Two Sum IV - Input is a BST
- Minimum Distance Between BST Nodes

**Medium Problems:**

- Validate Binary Search Tree
- Kth Smallest Element in a BST
- Delete Node in a BST
- Convert BST to Greater Tree

**Hard Problems:**

- Recover Binary Search Tree
- Count of Smaller Numbers After Self

---

## Graph Patterns

### 8. Graph Traversal Pattern (DFS/BFS)

**Core Concept:** Explore graph nodes systematically using depth-first or breadth-first approaches.

**When to Use:**

- Finding connected components
- Path finding
- Cycle detection
- Topological sorting

**Implementation Templates:**

```javascript
// DFS Template
function dfsTraversal(graph, start) {
  const visited = new Set();
  const result = [];

  function dfs(node) {
    if (visited.has(node)) return;

    visited.add(node);
    result.push(node);

    for (let neighbor of graph[node]) {
      dfs(neighbor);
    }
  }

  dfs(start);
  return result;
}

// BFS Template
function bfsTraversal(graph, start) {
  const visited = new Set();
  const queue = [start];
  const result = [];

  visited.add(start);

  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node);

    for (let neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return result;
}
```

**Problem Categories:**

**Easy Problems:**

- Number of Islands
- Find if Path Exists in Graph
- Binary Tree Paths
- Flood Fill

**Medium Problems:**

- Clone Graph
- Course Schedule
- Pacific Atlantic Water Flow
- Word Ladder
- Rotting Oranges

**Hard Problems:**

- Word Ladder II
- Alien Dictionary
- Minimum Cost to Make at Least One Valid Path in a Grid

---

### 9. Union-Find Pattern

**Core Concept:** Efficiently handle dynamic connectivity queries and group elements.

**When to Use:**

- Cycle detection in undirected graphs
- Connected components
- Dynamic connectivity
- Kruskal's algorithm for MST

**Implementation Template:**

```javascript
class UnionFind {
  constructor(n) {
    this.parent = Array.from({ length: n }, (_, i) => i);
    this.rank = new Array(n).fill(0);
    this.components = n;
  }

  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]); // Path compression
    }
    return this.parent[x];
  }

  union(x, y) {
    const rootX = this.find(x);
    const rootY = this.find(y);

    if (rootX === rootY) return false;

    // Union by rank
    if (this.rank[rootX] < this.rank[rootY]) {
      this.parent[rootX] = rootY;
    } else if (this.rank[rootX] > this.rank[rootY]) {
      this.parent[rootY] = rootX;
    } else {
      this.parent[rootY] = rootX;
      this.rank[rootX]++;
    }

    this.components--;
    return true;
  }

  isConnected(x, y) {
    return this.find(x) === this.find(y);
  }
}
```

**Problem Categories:**

**Easy Problems:**

- Find if Path Exists in Graph
- Number of Provinces

**Medium Problems:**

- Number of Islands II
- Accounts Merge
- Most Stones Removed with Same Row or Column
- Redundant Connection

**Hard Problems:**

- Number of Islands II
- Redundant Connection II
- Minimize Malware Spread

---

## Dynamic Programming Patterns

### 10. 1D Dynamic Programming

**Core Concept:** Build solutions using previous results in a linear sequence.

**When to Use:**

- Fibonacci-like sequences
- Optimization problems with overlapping subproblems
- Decision making at each step

**Implementation Template:**

```javascript
function dpTemplate(n) {
  // Bottom-up approach
  const dp = new Array(n + 1);

  // Base cases
  dp[0] = baseCase0;
  dp[1] = baseCase1;

  // Fill the dp array
  for (let i = 2; i <= n; i++) {
    dp[i] = someFunction(dp[i - 1], dp[i - 2]);
  }

  return dp[n];
}

// Space optimized version
function dpSpaceOptimized(n) {
  let prev2 = baseCase0;
  let prev1 = baseCase1;

  for (let i = 2; i <= n; i++) {
    let current = someFunction(prev1, prev2);
    prev2 = prev1;
    prev1 = current;
  }

  return prev1;
}
```

**Problem Categories:**

**Easy Problems:**

- Climbing Stairs
- Fibonacci Number
- N-th Tribonacci Number
- Min Cost Climbing Stairs

**Medium Problems:**

- House Robber
- House Robber II
- Decode Ways
- Word Break
- Coin Change

**Hard Problems:**

- House Robber III
- Best Time to Buy and Sell Stock with Cooldown

---

### 11. 2D Dynamic Programming

**Core Concept:** Use 2D tables for problems involving two sequences or grid-based optimization.

**When to Use:**

- Grid path problems
- String matching problems
- Two sequence comparison
- Matrix optimization

**Implementation Template:**

```javascript
function twoDimensionalDP(m, n) {
  // Create 2D DP table
  const dp = Array(m)
    .fill()
    .map(() => Array(n).fill(0));

  // Initialize base cases
  for (let i = 0; i < m; i++) {
    dp[i][0] = initValue;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = initValue;
  }

  // Fill the table
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(
        dp[i - 1][j] + cost1,
        dp[i][j - 1] + cost2,
        dp[i - 1][j - 1] + cost3
      );
    }
  }

  return dp[m - 1][n - 1];
}
```

**Problem Categories:**

**Easy Problems:**

- Unique Paths
- Minimum Path Sum
- Range Sum Query 2D - Immutable

**Medium Problems:**

- Unique Paths II
- Edit Distance
- Longest Common Subsequence
- Maximum Square
- Coin Change 2

**Hard Problems:**

- Regular Expression Matching
- Wildcard Matching
- Distinct Subsequences
- Interleaving String

---

## Searching & Sorting Patterns

### 12. Binary Search Pattern

**Core Concept:** Efficiently search in sorted arrays or use binary search on answer space.

**When to Use:**

- Searching in sorted arrays
- Finding boundaries
- Search in rotated arrays
- Binary search on answer

**Implementation Templates:**

```javascript
// Standard Binary Search
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// Binary Search on Answer Space
function binarySearchOnAnswer(arr, target) {
  let left = minPossibleAnswer;
  let right = maxPossibleAnswer;

  while (left < right) {
    const mid = Math.floor((left + right) / 2);

    if (isValid(mid)) {
      right = mid; // Look for smaller valid answer
    } else {
      left = mid + 1; // Need larger answer
    }
  }

  return left;
}
```

**Problem Categories:**

**Easy Problems:**

- Binary Search
- Search Insert Position
- First Bad Version
- Sqrt(x)

**Medium Problems:**

- Find First and Last Position of Element in Sorted Array
- Search in Rotated Sorted Array
- Find Peak Element
- Koko Eating Bananas
- Capacity To Ship Packages Within D Days

**Hard Problems:**

- Median of Two Sorted Arrays
- Split Array Largest Sum
- Minimize Max Distance to Gas Station

---

## Advanced Patterns

### 13. Backtracking Pattern

**Core Concept:** Systematically explore all possibilities with pruning for constraint satisfaction problems.

**When to Use:**

- Generating all permutations/combinations
- Solving puzzles (N-Queens, Sudoku)
- Path finding with constraints
- Decision tree exploration

**Implementation Template:**

```javascript
function backtrackTemplate(candidates, target) {
  const result = [];
  const currentPath = [];

  function backtrack(startIndex, remaining) {
    // Base case - found solution
    if (remaining === 0) {
      result.push([...currentPath]);
      return;
    }

    // Pruning condition
    if (remaining < 0) return;

    // Explore all possibilities
    for (let i = startIndex; i < candidates.length; i++) {
      // Skip duplicates if needed
      if (i > startIndex && candidates[i] === candidates[i - 1]) {
        continue;
      }

      // Make choice
      currentPath.push(candidates[i]);

      // Recurse
      backtrack(i + 1, remaining - candidates[i]);

      // Backtrack
      currentPath.pop();
    }
  }

  backtrack(0, target);
  return result;
}
```

**Problem Categories:**

**Easy Problems:**

- Generate Parentheses (medium complexity but good for learning)

**Medium Problems:**

- Permutations
- Combinations
- Combination Sum
- Subsets
- Word Search
- Letter Combinations of a Phone Number

**Hard Problems:**

- N-Queens
- Sudoku Solver
- Word Search II
- Palindrome Partitioning II

---

### 14. Greedy Algorithm Pattern

**Core Concept:** Make locally optimal choices at each step to find global optimum.

**When to Use:**

- Activity selection problems
- Huffman coding
- Minimum spanning tree
- Interval scheduling

**Implementation Template:**

```javascript
function greedyTemplate(items) {
  // Sort items based on greedy criteria
  items.sort((a, b) => greedyCriteria(a, b));

  const result = [];
  let currentState = initialState;

  for (let item of items) {
    if (isValidChoice(item, currentState)) {
      result.push(item);
      currentState = updateState(currentState, item);
    }
  }

  return result;
}
```

**Problem Categories:**

**Easy Problems:**

- Assign Cookies
- Lemonade Change
- Best Time to Buy and Sell Stock II

**Medium Problems:**

- Jump Game
- Gas Station
- Partition Labels
- Queue Reconstruction by Height
- Non-overlapping Intervals

**Hard Problems:**

- Jump Game II
- Candy
- Meeting Rooms II
- Minimum Number of Taps to Open to Water a Garden

---

### 15. Divide and Conquer Pattern

**Core Concept:** Break problems into smaller subproblems, solve recursively, and combine results.

**When to Use:**

- Sorting algorithms
- Tree problems
- Array problems that can be split
- Mathematical computations

**Implementation Template:**

```javascript
function divideAndConquer(arr, left, right) {
  // Base case
  if (left >= right) {
    return baseCase;
  }

  // Divide
  const mid = Math.floor((left + right) / 2);
  const leftResult = divideAndConquer(arr, left, mid);
  const rightResult = divideAndConquer(arr, mid + 1, right);

  // Conquer - combine results
  return combine(leftResult, rightResult);
}
```

**Problem Categories:**

**Easy Problems:**

- Maximum Subarray (Kadane's algorithm is simpler, but D&C works)
- Merge Two Sorted Lists

**Medium Problems:**

- Sort an Array (Merge Sort)
- Kth Largest Element in an Array (Quick Select)
- Different Ways to Add Parentheses
- Count of Smaller Numbers After Self

**Hard Problems:**

- Merge k Sorted Lists
- The Skyline Problem
- Count of Range Sum

---

## Learning Strategy by Difficulty

### Week 1-2: Foundation

Focus on Easy problems from each pattern to understand core concepts:

- Two Pointers: Valid Palindrome, Two Sum
- Sliding Window: Maximum Sum Subarray of Size K
- Linked List: Reverse Linked List, Merge Two Sorted Lists
- Tree Traversal: Inorder/Preorder/Postorder Traversal
- Binary Search: Binary Search, Search Insert Position

### Week 3-4: Building Confidence

Move to Medium problems while reviewing Easy ones:

- Two Pointers: 3Sum, Container With Most Water
- Sliding Window: Longest Substring Without Repeating Characters
- Tree: Binary Tree Level Order Traversal, Validate BST
- Graph: Number of Islands, Course Schedule
- DP: House Robber, Coin Change

### Week 5-6: Advanced Problem Solving

Tackle Hard problems and complex variations:

- Backtracking: N-Queens, Sudoku Solver
- DP: Edit Distance, Regular Expression Matching
- Graph: Word Ladder II, Alien Dictionary
- Advanced Tree: Binary Tree Maximum Path Sum

### Week 7-8: Mixed Practice

Solve problems without looking at categories to improve pattern recognition:

- Daily mixed practice sessions
- Timed problem solving
- Mock interview practice

---

## Practice Resources

### Online Platforms

- **LeetCode**: Best for categorized practice
- **HackerRank**: Good for algorithm fundamentals
- **CodeSignal**: Interview-style problems
- **Codeforces**: Competitive programming

### Books

- "Cracking the Coding Interview" by Gayle McDowell
- "Elements of Programming Interviews" by Aziz, Lee, and Prakash
- "Algorithm Design Manual" by Steven Skiena

### Tracking Progress

Create a spreadsheet to track:

- Problems solved by pattern
- Difficulty level completed
- Time taken for each problem
- Areas needing more practice
- Pattern recognition accuracy

Remember: Consistency and understanding patterns deeply is more important than solving many problems superficially. Focus on one pattern at a time and master it before moving on.
